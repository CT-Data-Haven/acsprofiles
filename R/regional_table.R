#' Make ACS table for a region of towns
#'
#' Makes ACS table aggregated across a region of towns
#'
#' @param town_list A character vector of the names or FIPS codes of towns in the region
#' @param name Name of the region. Defaults to "Aggregate"
#' @param town_lookup A data.frame or tbl. Must have columns \code{town} and \code{county}, as generated by \code{\link{get_town_names}}
#' @param state Either a number corresponding to the state's FIPS code, or a string with the state's two-letter abbreviation or full name. Defaults to 9, FIPS code for Connecticut
#' @param table.number String corresponding to an ACS table number; this is case-sensitive
#' @param year Endyear of ACS estimates as a four-digit integer
#'
#' @return Returns an \code{\link[acs]{acs-class}} object, as is standard from the \code{acs} package.
#'
#' @seealso \code{\link{get_town_names}}, which returns a dataframe of towns and countied formatted for \code{town_lookup}
#' @examples
#' inner_ring <- c("Hamden", "East Haven", "West Haven")
#' ct_towns <- get_town_names(state = 9)
#' inner_ring_pops <- regional_table(inner_ring, name = "Inner Ring", ct_towns, table.number = "B01003")
#'
#' @export
regional_table <- function(town_list, name = "Aggregate", town_lookup, state = 9, table.number, year = 2015) {
  geo <- acs::geo.make(state = state,
                  county = dplyr::filter(town_lookup, town %in% town_list)$county,
                  county.subdivision = dplyr::filter(town_lookup, town %in% town_list)$town,
                  combine = T,
                  combine.term = name)
  table <- acs::acs.fetch(geography = geo, endyear = year, table.number = table.number, col.names = "pretty")
  return(table)
}
