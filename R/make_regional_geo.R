#' Create regional geography
#'
#' Merge towns into an ACS geo set
#'
#' @param town_list A character vector of the names or FIPS codes of towns in the region
#' @param name Name of the region. Defaults to "Aggregate"
#' @param town_lookup A data.frame or tbl. Must have columns \code{town} and \code{county}, as generated by \code{\link{get_town_names}}
#' @param state Either a number corresponding to the state's FIPS code, or a string with the state's two-letter abbreviation or full name. Defaults to 09, FIPS code for Connecticut
#'
#' @return Returns a \code{\link[acs]{geo.set}} object.
#'
#' @seealso \code{\link{get_town_names}}, which returns a dataframe of towns and countied formatted for \code{town_lookup}
#'
#' @examples
#' inner_ring <- c("Hamden", "East Haven", "West Haven")
#' ct_towns <- get_town_names(state = 9, year = 2015)
#' ir_geo <- make_regional_geo(inner_ring, name = "Inner Ring",
#'   town_lookup = ct_towns, state = 9)
#'
#' @export
make_regional_geo <- function(town_list, name = "Aggregate", town_lookup, state = 9) {
  if(!"county" %in% names(town_lookup)) stop("town_lookup missing column county. Try again with function get_town_names")
  if(!"town" %in% names(town_lookup)) stop("town_lookup missing column town. Try again with function get_town_names")

  geo <- acs::geo.make(state = state,
                  county = dplyr::filter(town_lookup, town %in% town_list)$county,
                  county.subdivision = dplyr::filter(town_lookup, town %in% town_list)$town,
                  combine = T,
                  combine.term = name)
  return(geo)
}
